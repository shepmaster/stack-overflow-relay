use crate::stack_overflow::{AccessToken, AccountId};
use diesel::prelude::*;
use futures::{
    channel::{mpsc, oneshot},
    SinkExt, StreamExt,
};

mod models;
mod schema;

pub struct Db {
    conn: diesel::PgConnection,
}

impl Db {
    pub fn new(conn: diesel::PgConnection) -> Self {
        Self { conn }
    }
}

impl Db {
    fn register(&self, a: AccountId, b: AccessToken) {
        use models::Registration;
        use schema::registrations::dsl::*;

        let Self { conn } = self;

        let registration = Registration {
            account_id: a.0,
            access_token: b.0,
        };

        diesel::insert_into(registrations)
            .values(&registration)
            .on_conflict(account_id)
            .do_update()
            .set(access_token.eq(access_token))
            .execute(conn)
            .expect("TODO");
    }
}

// Can this be auto-generated by a proc-macro?
// https://draft.ryhl.io/blog/actors-with-tokio/

pub fn spawn(this: Db) -> (DbHandle, tokio::task::JoinHandle<()>) {
    let (tx, rx) = mpsc::channel(10);
    let child = tokio::spawn(db_task(this, rx));
    (DbHandle(tx), child)
}

#[derive(Debug, Clone)]
pub struct DbHandle(mpsc::Sender<DbCommand>);

impl DbHandle {
    pub async fn register(&mut self, a: AccountId, b: AccessToken) {
        let (tx, rx) = oneshot::channel();

        // Ignore send errors. If this send fails, so does the
        // rx.await below. There's no reason to check for the
        // same failure twice.
        let _ = self.0.send(DbCommand::Register(tx, a, b)).await;
        rx.await.expect("TODO")
    }
}

#[derive(Debug)]
enum DbCommand {
    Register(oneshot::Sender<()>, AccountId, AccessToken),
}

async fn db_task(#[allow(unused_mut)] mut this: Db, mut rx: mpsc::Receiver<DbCommand>) {
    while let Some(cmd) = rx.next().await {
        match cmd {
            DbCommand::Register(__r, a, b) => {
                // Macro: block_in_place vs nothing vs spawn_blocking
                let retval = tokio::task::block_in_place(|| this.register(a, b));

                // If we couldn't respond, that's OK
                let _ = __r.send(retval);
            }
        }
    }
}

//
