use crate::{
    stack_overflow::{self, AccessToken, AccountId, UnreadParams},
    GlobalConfig, GlobalStackOverflowConfig,
};
use futures::{
    channel::{mpsc, oneshot},
    future::RemoteHandle,
    FutureExt, SinkExt, StreamExt,
};
use std::collections::HashMap;
use tokio::task::JoinHandle;
use tracing::{trace, warn};

#[derive(Debug)]
pub struct PollSpawner {
    config: GlobalConfig,
    so_config: GlobalStackOverflowConfig,
    pollers: HashMap<AccountId, RemoteHandle<()>>,
}

// Not part of actor API
impl PollSpawner {
    pub fn new(config: GlobalConfig, so_config: GlobalStackOverflowConfig) -> Self {
        Self {
            config,
            so_config,
            pollers: Default::default(),
        }
    }
}

// Actor API
impl PollSpawner {
    fn start_polling(&mut self, account_id: AccountId, access_token: AccessToken) {
        trace!("starting new poller for {:?}", account_id);

        let Self {
            config,
            so_config,
            pollers,
        } = self;

        // `remote_handle` should kill the future when the
        // `handle` is dropped, which will happen if we replace
        // the hashmap entry for the same account.
        let (work, handle) =
            poll_one_account(config, so_config, account_id, access_token).remote_handle();
        tokio::spawn(work);
        let old_work = pollers.insert(account_id, handle);

        if let Some(old_work) = old_work {
            if old_work.now_or_never().is_none() {
                warn!("Second worker started for {:?}", account_id);
            }
        }
    }
}

async fn poll_one_account(
    config: GlobalConfig,
    so_config: GlobalStackOverflowConfig,
    account_id: AccountId,
    access_token: AccessToken,
) {
    trace!("poll_one_account started for {:?}", account_id);

    let params = UnreadParams {
        key: &config.stack_overflow_client_key,
        site: "stackoverflow",
        access_token: &access_token,
        filter: "default",
    };

    let r = stack_overflow::unread_notifications(so_config, &params).await;

    dbg!(&r);
}

// Can this be auto-generated by a proc-macro?
// https://draft.ryhl.io/blog/actors-with-tokio/

pub fn spawn(this: PollSpawner) -> (PollSpawnerHandle, JoinHandle<()>) {
    let (tx, rx) = mpsc::channel(10);
    let child = tokio::spawn(poll_spawner_task(this, rx));
    (PollSpawnerHandle(tx), child)
}

#[derive(Debug, Clone)]
pub struct PollSpawnerHandle(mpsc::Sender<PollSpawnerCommand>);

impl PollSpawnerHandle {
    pub async fn start_polling(&mut self, a: AccountId, b: AccessToken) {
        let (tx, rx) = oneshot::channel();

        // Ignore send errors. If this send fails, so does the
        // rx.await below. There's no reason to check for the
        // same failure twice.
        let _ = self.0.send(PollSpawnerCommand::Register(tx, a, b)).await;
        rx.await.expect("TODO")
    }
}

#[derive(Debug)]
enum PollSpawnerCommand {
    Register(oneshot::Sender<()>, AccountId, AccessToken),
}

async fn poll_spawner_task(mut this: PollSpawner, mut rx: mpsc::Receiver<PollSpawnerCommand>) {
    while let Some(cmd) = rx.next().await {
        match cmd {
            PollSpawnerCommand::Register(__r, a, b) => {
                let retval = this.start_polling(a, b);
                // If we couldn't respond, that's OK
                let _ = __r.send(retval);
            }
        }
    }
}

//
